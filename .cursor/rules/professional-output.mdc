---
description: 
globs: 
alwaysApply: true
---
# Professional Output and Logging Guide

## Output Philosophy

Cascade CLI is a **professional development tool**. All user-facing output must be:
1. **Clear and actionable** - Tell users what's happening and what they can do
2. **Visually organized** - Use formatting, icons, and whitespace effectively
3. **Technically sound but not overwhelming** - Hide debug details, show what matters

## ‚ùå What NOT to Do

### Avoid Technical Logging in User Output
```rust
// ‚ùå BAD - Exposes internal implementation details
info!("Attempting to checkout branch: develop");
info!("Fetching from origin");
info!("Using git CLI fallback for fetch operation");
info!("‚úÖ Git CLI fetch succeeded");
info!("Pull completed successfully");
info!("Cherry-picked 222565602e6965633565b24732502fbbd5383219 -> a56efcf26cf6b8f4a62d1a86f3fcc507a0528a5f");
info!("‚úÖ Cherry-picked 222565602e6965633565b24732502fbbd5383219 -> a56efcf26cf6b8f4a62d1a86f3fcc507a0528a5f");
info!("Force-pushing initial-commit-temp-1759190884 content to initial-commit to preserve PR history");
```

**Problems:**
- Uses generic INFO/WARN/DEBUG prefixes
- Shows internal temp branch names
- Duplicate messages (cherry-pick shown twice)
- Too verbose - 10+ lines for simple operations
- Technical jargon (OIDs, "fallback", "fetch succeeded")

## ‚úÖ Professional Output Patterns

### Use the Output Module (src/cli/output.rs)

The Output module provides consistent formatting methods. **CRITICAL**: Don't put emojis in strings - the Output methods add them automatically!

```rust
use crate::cli::output::Output;

// ‚úÖ CORRECT - Output methods add icons automatically
Output::section("Rebasing stack: my-feature");  // Bold underlined
println!(); // Spacing
println!("üìã Rebasing 2 entries");  // Visual tree header
println!("   ‚îú‚îÄ add-auth (PR #123)");  // Tree items
println!("   ‚îî‚îÄ add-tests (not submitted)");
println!(); // Spacing
Output::success("2 entries rebased (1 PR updated, 1 not yet submitted)");  // ‚úì added automatically

// ‚ùå WRONG - Don't duplicate emojis!
Output::success("‚úÖ Stack rebased");  // Output::success already adds ‚úì
Output::info("üìã Processing");  // Output::info already adds ‚Ñπ
```

### Output Module Methods

```rust
Output::section(title)    // Bold underlined header
Output::success(msg)       // ‚úì Green checkmark + message
Output::error(msg)         // ‚úó Red X + message  
Output::warning(msg)       // ‚ö† Yellow warning + message
Output::info(msg)          // ‚Ñπ Cyan info + message
Output::sub_item(msg)      // ‚Üí Dimmed arrow + message
Output::bullet(msg)        // ‚Ä¢ Bullet point
Output::tip(msg)           // üí° Bright tip icon
Output::numbered_item(n, msg)  // Numbered list item
```

### Visual Hierarchy - When to Use What

```rust
// 1. Section headers for major operations
Output::section(&format!("Syncing stack: {}", stack_name));

// 2. Visual tree structures - use plain println!()
println!(); // Spacing before tree
println!("üìã Rebasing {} entries", count);  // Tree header with emoji
for (i, entry) in entries.iter().enumerate() {
    let tree_char = if i == entries.len() - 1 { "‚îî‚îÄ" } else { "‚îú‚îÄ" };
    println!("   {} {} (PR #{})", tree_char, entry.name, pr_num);
}
println!(); // Spacing after tree

// 3. Summary/result with Output methods
Output::success(&format!("{} entries processed", count));  // Adds ‚úì

// 4. Sub-items for hierarchical info
Output::sub_item(format!("Branch: {}", branch));  // Adds ‚Üí
Output::sub_item(format!("PR: #{}", pr_id));
```

### Tree Structures - Use Plain println!()

For visual tree structures, **don't use Output methods** - they add unwanted prefixes:

```rust
// ‚úÖ CORRECT - Plain println for trees
println!("üìã Processing entries:");
println!("   ‚îú‚îÄ feature-1");
println!("   ‚îú‚îÄ feature-2");
println!("   ‚îî‚îÄ feature-3");

// ‚ùå WRONG - Output methods add extra icons
Output::info("üìã Processing entries:");  // Shows: ‚Ñπ üìã Processing entries:
Output::progress("   ‚îú‚îÄ feature-1");     // Shows: ‚Üí ‚îú‚îÄ feature-1 (wrong!)
```

## Logging vs User Output

### Use `tracing` for Technical Logs
```rust
// Technical details go to logs (debug/trace level)
debug!("Cherry-picking commit {}", commit_hash);
debug!("Resolved {} conflicts automatically", count);
trace!("Full diff: {}", diff_output);

// Critical errors go to warn/error
warn!("Failed to delete temp branch {}: {}", name, err);
error!("Repository corruption detected: {}", details);
```

### Use `Output` for User Messages
```rust
// User sees clean, actionable information
Output::info("Applying changes...");
Output::success("‚úì Changes applied");
```

## Contextual Output

### Show What Matters in Context
```rust
// ‚úÖ GOOD - For submitted PRs, show PR number
if let Some(pr_id) = entry.pull_request_id {
    Output::progress(&format!("   ‚îú‚îÄ {} (PR #{})", branch, pr_id));
} else {
    Output::progress(&format!("   ‚îú‚îÄ {} (not submitted)", branch));
}

// ‚ùå BAD - Always show internal IDs
Output::progress(&format!("Processing entry {}", entry.id)); // UUIDs not helpful
```

### Progressive Disclosure
```rust
// Start with summary, allow drilling down
Output::section("Stack Status");
Output::info(&format!("3 entries, 2 with PRs"));

// Only show details if user requests (--verbose flag)
if verbose {
    for entry in entries {
        println!("  {} - {} - {}", entry.hash[..8], entry.branch, entry.message);
    }
}
```

## Error Messaging

### Actionable Error Messages
```rust
// ‚ùå BAD - Technical, no guidance
return Err(CascadeError::git("cherry-pick failed"));

// ‚úÖ GOOD - Explains problem and solution
return Err(CascadeError::git(
    "Cherry-pick failed due to conflicts. Run 'ca conflicts' to see details, \
     or 'ca rebase --interactive' to resolve manually"
));
```

### Error Context
```rust
// ‚úÖ GOOD - Show what failed and why
Output::error(&format!(
    "Could not rebase '{}': conflicts with base branch",
    branch_name
));
Output::tip("Resolve conflicts manually or run 'ca conflicts analyze'");
```

## Real-World Examples

### Sync Command Output

**BEFORE (unprofessional):**
```
INFO Attempting to checkout branch: develop
‚úì Switched to branch 'develop'
INFO Pulling branch: develop
INFO Fetching from origin
INFO Using git CLI fallback for fetch operation
INFO ‚úÖ Git CLI fetch succeeded
INFO Pull completed successfully
INFO Starting rebase for stack 4cb8c214-afff-4dfd-9072-932ec0ec2847
INFO Attempting to checkout branch: initial-commit-temp-1759190884
...15 more INFO lines...
```

**AFTER (professional):**
```
Rebasing stack: create-base-component
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üìã Rebasing 2 entries
   ‚îú‚îÄ add-auth (PR #123)
   ‚îî‚îÄ add-tests (not submitted)

‚úì 2 entries rebased (1 PR updated, 1 not yet submitted)
```

**Code that produces AFTER output:**
```rust
Output::section(&format!("Rebasing stack: {}", stack.name));
println!();
println!("üìã Rebasing {} entries", entry_count);
for (i, entry) in stack.entries.iter().enumerate() {
    let tree_char = if i + 1 == entry_count { "‚îî‚îÄ" } else { "‚îú‚îÄ" };
    println!("   {} {} (PR #{})", tree_char, entry.branch, pr_num);
}
println!();
Output::success("2 entries rebased (1 PR updated, 1 not yet submitted)");
```

### Submit Command Output

**GOOD:**
```
üì§ Submitting stack entries to Bitbucket

‚úì Created PR #123: add-auth ‚Üí develop
‚úì Created PR #124: add-tests ‚Üí add-auth

üìã Summary: 2 PRs created
   View in browser: https://bitbucket.org/project/repo/pull-requests/123
```

## Configuration

### Output Verbosity Levels
```rust
// Normal: Show high-level progress and results
Output::info("Rebasing stack...");
Output::success("‚úì Done");

// Verbose (-v): Show operation details
if verbose {
    Output::progress("   Updating branch: feature-1");
    Output::progress("   Updating branch: feature-2");
}

// Quiet (-q): Show only errors and critical info
if !quiet {
    Output::success("‚úì Stack synced");
}
```

## Testing Output

### Capture and Verify Output in Tests
```rust
#[test]
fn test_sync_output() {
    let output = capture_output(|| {
        sync_stack(&stack).unwrap();
    });
    
    // Verify professional output format
    assert!(output.contains("üìã Rebasing"));
    assert!(!output.contains("INFO")); // No technical prefixes
    assert!(!output.contains("-temp-")); // No temp branch names
}
```

## Common Anti-Patterns

### ‚ùå Implementation Details Leaking
```rust
// BAD - User doesn't care about temp branches
println!("Force-pushing feature-temp-1234567890 to feature");

// GOOD - Focus on user's branch
Output::progress("   ‚îî‚îÄ feature (PR #123)");
```

### ‚ùå Duplicate Messages
```rust
// BAD - Same info twice
info!("Cherry-picking commit abc123");
info!("‚úÖ Cherry-picked abc123 -> def456");

// GOOD - One clear message
debug!("Cherry-picked {} -> {}", old_hash, new_hash); // Logs only
```

### ‚ùå Technical Jargon
```rust
// BAD
println!("OID mismatch detected in refs/heads/feature");

// GOOD
Output::warning("Branch 'feature' has diverged from remote");
Output::tip("Run 'ca sync' to update");
```

## Summary

**Golden Rules:**
1. **User output** = Professional, clear, actionable (use `Output`)
2. **Technical logs** = Debug details for troubleshooting (use `tracing`)
3. **Visual hierarchy** = Sections, trees, icons, consistent formatting
4. **Context matters** = Show PR numbers for submitted work, hide UUIDs
5. **Progressive disclosure** = Summary by default, details on request